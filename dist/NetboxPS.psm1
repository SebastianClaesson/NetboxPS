<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.150
     Generated on:       5/11/2018 3:48 PM
     Generated by:       Ben Claussen
     Organization:       NEOnet
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2018
#>


#region Invoke-Helpers_ps1
	<#	
		.NOTES
		===========================================================================
	     Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.148
		 Created on:   	2/28/2018 3:33 PM
		 Created by:   	Ben Claussen
		 Organization: 	NEOnet
		 Filename:     	Helpers.ps1
		===========================================================================
		.DESCRIPTION
			These function are internal functions and generally are not
	        exposed to the end user
	#>
	
	function CheckNetboxIsConnected {
		[CmdletBinding()]
	    param ()
	    
	    Write-Verbose "Checking connection status"
		if (-not $script:NetboxConfig.Connected) {
			throw "Not connected to a Netbox API! Please run 'Connect-NetboxAPI'"
	    }
	}
	
	function BuildNewURI {
	<#
	    .SYNOPSIS
	        Create a new URI for Netbox
	    
	    .DESCRIPTION
	        A detailed description of the BuildNewURI function.
	    
	    .PARAMETER Hostname
	        Hostname of the Netbox API
	    
	    .PARAMETER Segments
	        Array of strings for each segment in the URL path
	    
	    .PARAMETER Parameters
	        Hashtable of query parameters to include
	    
	    .PARAMETER HTTPS
	        Whether to use HTTPS or HTTP
	    
	    .PARAMETER Port
	        A description of the Port parameter.
	    
	    .PARAMETER APIInfo
	        A description of the APIInfo parameter.
	    
	    .EXAMPLE
	        PS C:\> BuildNewURI
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    [OutputType([System.UriBuilder])]
	    param
	    (
	        [Parameter(Mandatory = $false)]
	        [string]$Hostname,
	        
	        [Parameter(Mandatory = $false)]
	        [string[]]$Segments,
	        
	        [Parameter(Mandatory = $false)]
	        [hashtable]$Parameters,
	        
	        [Parameter(Mandatory = $false)]
	        [boolean]$HTTPS = $true,
	        
	        [ValidateRange(1, 65535)]
	        [uint16]$Port = 443,
	        
	        [switch]$SkipConnectedCheck
	    )
	    
	    Write-Verbose "Building URI"
	    
	    if (-not $SkipConnectedCheck) {
	        # There is no point in continuing if we have not successfully connected to an API
	        $null = CheckNetboxIsConnected
	    }
	    
	    if (-not $Hostname) {
	        $Hostname = Get-NetboxHostname
	    }
	    
	    if ($HTTPS) {
	        Write-Verbose "Setting scheme to HTTPS"
	        $Scheme = 'https'
	    } else {
	        Write-Warning "Connecting via non-secure HTTP is not-recommended"
	        
	        Write-Verbose "Setting scheme to HTTP"
	        $Scheme = 'http'
	        
	        if (-not $PSBoundParameters.ContainsKey('Port')) {
	            # Set the port to 80 if the user did not supply it
	            Write-Verbose "Setting port to 80 as default because it was not supplied by the user"
	            $Port = 80
	        }
	    }
	    
	    # Begin a URI builder with HTTP/HTTPS and the provided hostname
	    $uriBuilder = [System.UriBuilder]::new($Scheme, $Hostname, $Port)
	        
	    # Generate the path by trimming excess slashes and whitespace from the $segments[] and joining together
	    $uriBuilder.Path = "api/{0}/" -f ($Segments.ForEach({$_.trim('/').trim()}) -join '/')
	    
	    Write-Verbose "URIPath: $($uriBuilder.Path)"
	    
	    if ($parameters) {
	        # Loop through the parameters and use the HttpUtility to create a Query string
	        [System.Collections.Specialized.NameValueCollection]$URIParams = [System.Web.HttpUtility]::ParseQueryString([String]::Empty)
	        
	        foreach ($param in $Parameters.GetEnumerator()) {
	            Write-Verbose "Adding URI parameter $($param.Key):$($param.Value)"
	            $URIParams[$param.Key] = $param.Value
	        }
	        
	        $uriBuilder.Query = $URIParams.ToString()
	    }
	    
	    Write-Verbose "Completed building URIBuilder"
	    # Return the entire UriBuilder object
	    $uriBuilder
	}
	
	function GetNetboxAPIErrorBody {
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [System.Net.HttpWebResponse]$Response
	    )
	    
	    # This takes the $Response stream and turns it into a useable object... generally a string.
	    # If the body is JSON, you should be able to use ConvertFrom-Json
	    
	    $reader = New-Object System.IO.StreamReader($Response.GetResponseStream())
	    $reader.BaseStream.Position = 0
	    $reader.DiscardBufferedData()
	    $reader.ReadToEnd()
	}
	
	function InvokeNetboxRequest {
	    [CmdletBinding(SupportsShouldProcess = $true)]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [System.UriBuilder]$URI,
	        
	        [Hashtable]$Headers = @{},
	        
	        [pscustomobject]$Body = $null,
	        
	        [ValidateRange(0, 60)]
	        [uint16]$Timeout = 5,
	        
	        [ValidateSet('GET', 'PATCH', 'PUT', 'POST', 'DELETE', IgnoreCase = $true)]
	        [string]$Method = 'GET',
	        
	        [switch]$Raw
	    )
	    
	    $creds = Get-NetboxCredentials
	    
	    $Headers.Authorization = "Token {0}" -f $creds.GetNetworkCredential().Password
	    
	    $splat = @{
	        'Method' = $Method
	        'Uri' = $URI.Uri.AbsoluteUri # This property auto generates the scheme, hostname, path, and query
	        'Headers' = $Headers
	        'TimeoutSec' = $Timeout
	        'ContentType' = 'application/json'
	        'ErrorAction' = 'Stop'
	        'Verbose' = $VerbosePreference
	    }
	    
	    if ($Body) {
	        Write-Verbose "BODY: $($Body | ConvertTo-Json -Compress)"
	        $null = $splat.Add('Body', ($Body | ConvertTo-Json -Compress))
	    }
	    
	    $result = Invoke-RestMethod @splat
	    
	    #region TODO: Handle errors a little more gracefully...
	    
	    <#
	    try {
	        Write-Verbose "Sending request..."
	        $result = Invoke-RestMethod @splat
	        Write-Verbose $result
	    } catch {
	        Write-Verbose "Caught exception"
	        if ($_.Exception.psobject.properties.Name.contains('Response')) {
	            Write-Verbose "Exception contains a response property"
	            if ($Raw) {
	                Write-Verbose "RAW provided...throwing raw exception"
	                throw $_
	            }
	            
	            Write-Verbose "Converting response to object"
	            $myError = GetNetboxAPIErrorBody -Response $_.Exception.Response | ConvertFrom-Json
	        } else {
	            Write-Verbose "No response property found"
	            $myError = $_
	        }
	    }
	    
	    Write-Verbose "MyError is $($myError.GetType().FullName)"
	    
	    if ($myError -is [Exception]) {
	        throw $_
	    } elseif ($myError -is [pscustomobject]) {
	        throw $myError.detail
	    }    
	    #>
	    
	    #endregion TODO: Handle errors a little more gracefully...
	    
	    # If the user wants the raw value from the API... otherwise return only the actual result
	    if ($Raw) {
	        Write-Verbose "Returning raw result"
	        return $result
	    } else {
	        if ($result.psobject.Properties.Name.Contains('results')) {
	            Write-Verbose "Found Results property on data, returning results directly"
	            return $result.Results
	        } else {
	            Write-Verbose "Did NOT find results property on data, returning raw result"
	            return $result
	        }
	    }    
	}
	
	function ThrowNetboxRESTError {
	    $uriSegments = [System.Collections.ArrayList]::new(@('fake', 'url'))
	    
	    $URIParameters = @{}
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $URIParameters
	    
	    InvokeNetboxRequest -URI $uri -Raw
	}
	
	
	
	
	
	
	
	
	
	#endregion

#region Invoke-Setup_ps1
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.148
		 Created on:   	2/28/2018 3:33 PM
		 Created by:   	Ben Claussen
		 Organization: 	NEOnet
		 Filename:     	Setup.ps1
		===========================================================================
		.DESCRIPTION
			These are the function used to setup the environment for connecting
	        to a Netbox API
	#>
	
	function SetupNetboxConfigVariable {
	    [CmdletBinding()]
	    param
	    (
	        [switch]$Overwrite
	    )
	    
	    Write-Verbose "Checking for NetboxConfig hashtable"
	    if ((-not ($script:NetboxConfig)) -or $Overwrite) {
	        Write-Verbose "Creating NetboxConfig hashtable"
	        $script:NetboxConfig = @{
	            'Connected' = $false
	            'Choices' = @{
	                'Circuits' = $null
	                'DCIM' = $null
	                'Extras' = $null
	                'IPAM' = $null
	                'Secrets' = $null
	                'Tenancy' = $null
	                'Virtualization' = $null
	            }
	        }
	    }
	    
	    Write-Verbose "NetboxConfig hashtable already exists"
	}
	
	function GetNetboxConfigVariable {
	    return $script:NetboxConfig
	}
	
	function Set-NetboxHostName {
		[CmdletBinding()]
		param
		(
			[Parameter(Mandatory = $true)]
			[string]$Hostname
		)
		
		$script:NetboxConfig.Hostname = $Hostname.Trim()
		$script:NetboxConfig.Hostname
	}
	
	function Get-NetboxHostname {
		[CmdletBinding()]
		param ()
	    
	    Write-Verbose "Getting Netbox hostname"
		if ($script:NetboxConfig.Hostname -eq $null) {
			throw "Netbox Hostname is not set! You may set it with Set-NetboxHostname -Hostname 'hostname.domain.tld'"
		}
		
		$script:NetboxConfig.Hostname
	}
	
	function Set-NetboxCredentials {
		[CmdletBinding(DefaultParameterSetName = 'CredsObject')]
		[OutputType([pscredential], ParameterSetName = 'CredsObject')]
		[OutputType([pscredential], ParameterSetName = 'UserPass')]
		param
		(
			[Parameter(ParameterSetName = 'CredsObject',
					   Mandatory = $true)]
			[pscredential]$Credentials,
			
			[Parameter(ParameterSetName = 'UserPass',
					   Mandatory = $true)]
			[string]$Token
		)
		
		switch ($PsCmdlet.ParameterSetName) {
			'CredsObject' {
				$script:NetboxConfig.Credentials = $Credentials
				break
			}
			
			'UserPass' {
				$securePW = ConvertTo-SecureString $Token -AsPlainText -Force
				$script:NetboxConfig.Credentials = [System.Management.Automation.PSCredential]::new('notapplicable', $securePW)
				break
			}
		}
		
		$script:NetboxConfig.Credentials
	}
	
	function Get-NetboxCredentials {
		[CmdletBinding()]
		[OutputType([pscredential])]
		param ()
		
		if (-not $script:NetboxConfig.Credentials) {
			throw "Netbox Credentials not set! You may set with Set-NetboxCredentials"
		}
		
		$script:NetboxConfig.Credentials
	}
	
	function VerifyAPIConnectivity {
	    [CmdletBinding()]
	    param ()
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('extras', '_choices'))
	    
	    $uri = BuildNewURI -Segments $uriSegments -SkipConnectedCheck
	    
	    InvokeNetboxRequest -URI $uri
	}
	
	function Connect-NetboxAPI {
	<#
	    .SYNOPSIS
	        Connects to the Netbox API and ensures credentials work properly
	    
	    .DESCRIPTION
	        A detailed description of the Connect-NetboxAPI function.
	    
	    .PARAMETER Hostname
	        A description of the Hostname parameter.
	    
	    .PARAMETER Credentials
	        A description of the Credentials parameter.
	    
	    .EXAMPLE
	        PS C:\> Connect-NetboxAPI -Hostname "netbox.domain.com"
	        
	        This will prompt for credentials, then proceed to attempt a connection to Netbox
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [string]$Hostname,
	        
	        [Parameter(Mandatory = $false)]
	        [pscredential]$Credentials
	    )
	    
	    if (-not $Credentials) {
	        try {
	            $Credentials = Get-NetboxCredentials -ErrorAction Stop
	        } catch {
	            # Credentials are not set... Try to obtain from the user
	            if (-not ($Credentials = Get-Credential -UserName 'username-not-applicable' -Message "Enter token for Netbox")) {
	                throw "Token is necessary to connect to a Netbox API."
	            }
	        }
	    }
	    
	    $null = Set-NetboxHostName -Hostname $Hostname
	    $null = Set-NetboxCredentials -Credentials $Credentials
	    
	    try {
	        Write-Verbose "Verifying API connectivity..."
	        $APIInfo = VerifyAPIConnectivity
	        $script:NetboxConfig.Connected = $true
	        Write-Verbose "Successfully connected!"
	    } catch {
	        Write-Verbose "Failed to connect. Generating error"
	        Write-Verbose $_.Exception.Message
	        if (($_.Exception.Response) -and ($_.Exception.Response.StatusCode -eq 403)) {
	            throw "Invalid token"
	        } else {
	            throw $_
	        }
	    }
	    
	    $script:NetboxConfig.Choices.Circuits = Get-NetboxCircuitsChoices
	    #$script:NetboxConfig.Choices.DCIM = Get-NetboxDCIMChoices
	    $script:NetboxConfig.Choices.Extras = Get-NetboxExtrasChoices
	    $script:NetboxConfig.Choices.IPAM = Get-NetboxIPAMChoices
	    #$script:NetboxConfig.Choices.Secrets = Get-NetboxSecretsChoices
	    #$script:NetboxConfig.Choices.Tenancy = Get-NetboxTenancyChoices
	    $script:NetboxConfig.Choices.Virtualization = Get-NetboxVirtualizationChoices
	    
	}
	
	
	
	
	
	
	
	
	
	
	#endregion

#region Invoke-Extras_ps1
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.148
		 Created on:   	2/28/2018 3:43 PM
		 Created by:   	Ben Claussen
		 Organization: 	NEOnet
		 Filename:     	Extras.ps1
		===========================================================================
		.DESCRIPTION
			Extras objects functions
	#>
	
	function Get-NetboxExtrasChoices {
		[CmdletBinding()]
		param ()
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('extras', '_choices'))
	    
	    $uri = BuildNewURI -Segments $uriSegments
	    
	    InvokeNetboxRequest -URI $uri
	}
	#endregion

#region Invoke-Circuits_ps1
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.148
		 Created on:   	2/28/2018 4:06 PM
		 Created by:   	Ben Claussen
		 Organization: 	NEOnet
		 Filename:     	Circuits.ps1
		===========================================================================
		.DESCRIPTION
			Circuit object functions
	#>
	
	function Get-NetboxCircuitsChoices {
	<#
		.SYNOPSIS
			Gets the choices associated with circuits
		
		.DESCRIPTION
			A detailed description of the Get-NetboxCircuitsChoices function.
		
		.EXAMPLE
					PS C:\> Get-NetboxCircuitsChoices
		
		.NOTES
			Additional information about the function.
	#>
		
		[CmdletBinding()]
		param ()
		
		$uriSegments = [System.Collections.ArrayList]::new(@('circuits', '_choices'))
		$uri = BuildNewURI -Segments $uriSegments
		
		InvokeNetboxRequest -URI $uri
	}
	
	function Get-NetboxCircuit {
	<#
		.SYNOPSIS
			Gets one or more circuits
		
		.DESCRIPTION
			A detailed description of the Get-NetboxCircuit function.
		
		.PARAMETER CID
			Circuit ID
		
		.PARAMETER InstallDate
			Date of installation
		
		.PARAMETER CommitRate
			Committed rate in Kbps
		
		.PARAMETER Query
			A raw search query... As if you were searching the web site
		
		.PARAMETER Provider
			The name or ID of the provider. Provide either [string] or [int]. String will search provider names, integer will search database IDs
		
		.PARAMETER Type
			Type of circuit. Provide either [string] or [int]. String will search provider type names, integer will search database IDs
		
		.PARAMETER Site
			Location/site of circuit. Provide either [string] or [int]. String will search site names, integer will search database IDs
		
		.PARAMETER Tenant
			Tenant assigned to circuit. Provide either [string] or [int]. String will search tenant names, integer will search database IDs
		
		.PARAMETER Id
			Database ID of circuit. This will query for exactly the IDs provided
		
		.PARAMETER ID__IN
			Multiple unique DB IDs to retrieve
		
		.EXAMPLE
			PS C:\> Get-NetboxCircuit
		
		.NOTES
			Additional information about the function.
	#>
		
		[CmdletBinding()]
		param
		(
			[string]$CID,
			
			[datetime]$InstallDate,
			
			[uint32]$CommitRate,
			
			[string]$Query,
			
			[object]$Provider,
			
			[object]$Type,
			
			[string]$Site,
			
			[string]$Tenant,
			
			[uint16[]]$Id
		)
		
		#TODO: Place script here
	}
	#endregion

#region Invoke-Virtualization_ps1
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.150
		 Created on:   	5/8/2018 3:59 PM
		 Created by:   	Ben Claussen
		 Organization: 	NEOnet
		 Filename:     	Virtualization.ps1
		===========================================================================
		.DESCRIPTION
			Virtualization object functions
	#>
	
	#region GET commands
	
	function Get-NetboxVirtualizationChoices {
	    [CmdletBinding()]
	    param ()
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('virtualization', '_choices'))
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $Parameters
	    
	    InvokeNetboxRequest -URI $uri
	}
	
	function Get-NetboxVirtualMachine {
	<#
	    .SYNOPSIS
	        Obtains virtual machines from Netbox.
	    
	    .DESCRIPTION
	        Obtains one or more virtual machines based on provided filters.
	    
	    .PARAMETER Limit
	        Number of results to return per page
	    
	    .PARAMETER Offset
	        The initial index from which to return the results
	    
	    .PARAMETER Query
	        A general query used to search for a VM
	    
	    .PARAMETER Name
	        Name of the VM
	    
	    .PARAMETER Id
	        Database ID of the VM
	    
	    .PARAMETER Status
	        Status of the VM
	    
	    .PARAMETER Tenant
	        String value of tenant
	    
	    .PARAMETER Tenant_ID
	        Database ID of the tenant.
	    
	    .PARAMETER Platform
	        String value of the platform
	    
	    .PARAMETER Platform_ID
	        Database ID of the platform
	    
	    .PARAMETER Cluster_Group
	        String value of the cluster group.
	    
	    .PARAMETER Cluster_Group_Id
	        Database ID of the cluster group.
	    
	    .PARAMETER Cluster_Type
	        String value of the Cluster type.
	    
	    .PARAMETER Cluster_Type_Id
	        Database ID of the cluster type.
	    
	    .PARAMETER Cluster_Id
	        Database ID of the cluster.
	    
	    .PARAMETER Site
	        String value of the site.
	    
	    .PARAMETER Site_Id
	        Database ID of the site.
	    
	    .PARAMETER Role
	        String value of the role.
	    
	    .PARAMETER Role_Id
	        Database ID of the role.
	    
	    .PARAMETER Raw
	        A description of the Raw parameter.
	    
	    .PARAMETER TenantID
	        Database ID of tenant
	    
	    .PARAMETER PlatformID
	        Database ID of the platform
	    
	    .PARAMETER id__in
	        Database IDs of VMs
	    
	    .EXAMPLE
	        PS C:\> Get-NetboxVirtualMachine
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    param
	    (
	        [uint16]$Limit,
	        
	        [uint16]$Offset,
	        
	        [Alias('q')]
	        [string]$Query,
	        
	        [string]$Name,
	        
	        [Alias('id__in')]
	        [uint16[]]$Id,
	        
	        [NetboxVirtualMachineStatus]$Status,
	        
	        [string]$Tenant,
	        
	        [uint16]$Tenant_ID,
	        
	        [string]$Platform,
	        
	        [uint16]$Platform_ID,
	        
	        [string]$Cluster_Group,
	        
	        [uint16]$Cluster_Group_Id,
	        
	        [string]$Cluster_Type,
	        
	        [uint16]$Cluster_Type_Id,
	        
	        [uint16]$Cluster_Id,
	        
	        [string]$Site,
	        
	        [uint16]$Site_Id,
	        
	        [string]$Role,
	        
	        [uint16]$Role_Id,
	        
	        [switch]$Raw
	    )
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('virtualization', 'virtual-machines'))
	    
	    $URIParameters = @{}
	    
	    foreach ($CmdletParameterName in $PSBoundParameters.Keys) {
	        if ($CmdletParameterName -in $CommonParameterNames) {
	            # These are common parameters and should not be appended to the URI
	            Write-Debug "Skipping parameter $CmdletParameterName"
	            continue
	        }
	        
	        if ($CmdletParameterName -eq 'Id') {
	            # Check if there is one or more values for Id and build a URI or query as appropriate
	            if (@($PSBoundParameters[$CmdletParameterName]).Count -gt 1) {
	                $URIParameters['id__in'] = $Id -join ','
	            } else {
	                [void]$uriSegments.Add($PSBoundParameters[$CmdletParameterName])
	            }
	        } elseif ($CmdletParameterName -eq 'Query') {
	            $URIParameters['q'] = $PSBoundParameters[$CmdletParameterName]
	        } elseif ($CmdletParameterName -eq 'Status') {
	            $URIParameters[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName].value__
	        } else {
	            $URIParameters[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName]
	        }
	    }
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $URIParameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	function Get-NetboxVirtualMachineInterface {
	<#
	    .SYNOPSIS
	        Gets VM interfaces
	    
	    .DESCRIPTION
	        Obtains the interface objects for one or more VMs
	    
	    .PARAMETER Limit
	        Number of results to return per page.
	    
	    .PARAMETER Offset
	        The initial index from which to return the results.
	    
	    .PARAMETER Id
	        Database ID of the interface
	    
	    .PARAMETER Name
	        Name of the interface
	    
	    .PARAMETER Enabled
	        True/False if the interface is enabled
	    
	    .PARAMETER MTU
	        Maximum Transmission Unit size. Generally 1500 or 9000
	    
	    .PARAMETER Virtual_Machine_Id
	        ID of the virtual machine to which the interface(s) are assigned.
	    
	    .PARAMETER Virtual_Machine
	        Name of the virtual machine to get interfaces
	    
	    .PARAMETER MAC_Address
	        MAC address assigned to the interface
	    
	    .PARAMETER Raw
	        A description of the Raw parameter.
	    
	    .EXAMPLE
	        PS C:\> Get-NetboxVirtualMachineInterface
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    param
	    (
	        [Parameter(ValueFromPipeline = $true,
	                   ValueFromPipelineByPropertyName = $true)]
	        [uint16]$Limit,
	        
	        [Parameter(ValueFromPipeline = $true,
	                   ValueFromPipelineByPropertyName = $true)]
	        [uint16]$Offset,
	        
	        [Parameter(ValueFromPipeline = $true)]
	        [uint16]$Id,
	        
	        [Parameter(ValueFromPipeline = $true)]
	        [string]$Name,
	        
	        [Parameter(ValueFromPipeline = $true)]
	        [boolean]$Enabled,
	        
	        [Parameter(ValueFromPipeline = $true)]
	        [uint16]$MTU,
	        
	        [Parameter(ValueFromPipeline = $true)]
	        [uint16]$Virtual_Machine_Id,
	        
	        [Parameter(ValueFromPipeline = $true)]
	        [string]$Virtual_Machine,
	        
	        [Parameter(ValueFromPipeline = $true)]
	        [string]$MAC_Address,
	        
	        [Parameter(ValueFromPipeline = $true,
	                   ValueFromPipelineByPropertyName = $true)]
	        [switch]$Raw
	    )
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('virtualization', 'interfaces'))
	    
	    $URIParameters = @{
	    }
	    
	    foreach ($CmdletParameterName in $PSBoundParameters.Keys) {
	        if ($CmdletParameterName -in $CommonParameterNames) {
	            # These are common parameters and should not be appended to the URI
	            Write-Debug "Skipping parameter $CmdletParameterName"
	            continue
	        }
	        
	        if ($CmdletParameterName -eq 'Id') {
	            [void]$uriSegments.Add($PSBoundParameters[$CmdletParameterName])
	        } elseif ($CmdletParameterName -eq 'Enabled') {
	            $URIParameters[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName].ToString().ToLower()
	        } else {
	            $URIParameters[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName]
	        }
	    }
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $URIParameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	function Get-NetboxVirtualizationCluster {
	<#
	    .SYNOPSIS
	        Obtains virtualization clusters from Netbox.
	    
	    .DESCRIPTION
	        Obtains one or more virtualization clusters based on provided filters.
	    
	    .PARAMETER Limit
	        Number of results to return per page
	    
	    .PARAMETER Offset
	        The initial index from which to return the results
	    
	    .PARAMETER Query
	        A general query used to search for a cluster
	    
	    .PARAMETER Name
	        Name of the cluster
	    
	    .PARAMETER Id
	        Database ID(s) of the cluster
	    
	    .PARAMETER Group
	        String value of the cluster group.
	    
	    .PARAMETER Group_Id
	        Database ID of the cluster group.
	    
	    .PARAMETER Type
	        String value of the Cluster type.
	    
	    .PARAMETER Type_Id
	        Database ID of the cluster type.
	    
	    .PARAMETER Site
	        String value of the site.
	    
	    .PARAMETER Site_Id
	        Database ID of the site.
	    
	    .PARAMETER Raw
	        A description of the Raw parameter.
	    
	    .EXAMPLE
	        PS C:\> Get-NetboxVirtualizationCluster
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    param
	    (
	        [uint16]$Limit,
	        
	        [uint16]$Offset,
	        
	        [Alias('q')]
	        [string]$Query,
	        
	        [string]$Name,
	        
	        [Alias('id__in')]
	        [uint16[]]$Id,
	        
	        [string]$Group,
	        
	        [uint16]$Group_Id,
	        
	        [string]$Type,
	        
	        [uint16]$Type_Id,
	        
	        [string]$Site,
	        
	        [uint16]$Site_Id,
	        
	        [switch]$Raw
	    )
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('virtualization', 'clusters'))
	    
	    $URIParameters = @{
	    }
	    
	    foreach ($CmdletParameterName in $PSBoundParameters.Keys) {
	        if ($CmdletParameterName -in $CommonParameterNames) {
	            # These are common parameters and should not be appended to the URI
	            Write-Debug "Skipping parameter $CmdletParameterName"
	            continue
	        }
	        
	        if ($CmdletParameterName -eq 'Id') {
	            # Check if there is one or more values for Id and build a URI or query as appropriate
	            if (@($PSBoundParameters[$CmdletParameterName]).Count -gt 1) {
	                $URIParameters['id__in'] = $Id -join ','
	            } else {
	                [void]$uriSegments.Add($PSBoundParameters[$CmdletParameterName])
	            }
	        } elseif ($CmdletParameterName -eq 'Query') {
	            $URIParameters['q'] = $PSBoundParameters[$CmdletParameterName]
	        } else {
	            $URIParameters[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName]
	        }
	    }
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $URIParameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	function Get-NetboxVirtualizationClusterGroup {
	    [CmdletBinding()]
	    param
	    (
	        [uint16]$Limit,
	        
	        [uint16]$Offset,
	        
	        [string]$Name,
	        
	        [string]$Slug,
	        
	        [switch]$Raw
	    )
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('virtualization', 'cluster-groups'))
	    
	    $URIParameters = @{}
	    
	    foreach ($CmdletParameterName in $PSBoundParameters.Keys) {
	        if ($CmdletParameterName -in $CommonParameterNames) {
	            # These are common parameters and should not be appended to the URI
	            Write-Debug "Skipping parameter $CmdletParameterName"
	            continue
	        }
	        
	        $URIParameters[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName]
	    }
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $URIParameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	#endregion GET commands
	
	
	#region ADD commands
	
	function Add-NetboxVirtualMachine {
	    [CmdletBinding()]
	    [OutputType([pscustomobject])]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [string]$Name,
	        
	        [Parameter(Mandatory = $true)]
	        [uint16]$Cluster,
	        
	        [uint16]$Tenant,
	        
	        [NetboxVirtualMachineStatus]$Status = 'Active',
	        
	        [uint16]$Role,
	        
	        [uint16]$Platform,
	        
	        [uint16]$vCPUs,
	        
	        [uint16]$Memory,
	        
	        [uint16]$Disk,
	        
	        [hashtable]$Custom_Fields,
	        
	        [string]$Comments
	    )
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('virtualization', 'virtual-machines'))
	    
	    $Body = @{}
	    
	    if (-not $PSBoundParameters.ContainsKey('Status')) {
	        [void]$PSBoundParameters.Add('Status', $Status)
	    }
	    
	    foreach ($CmdletParameterName in $PSBoundParameters.Keys) {
	        if ($CmdletParameterName -in $CommonParameterNames) {
	            # These are common parameters and should not be appended to the URI
	            Write-Debug "Skipping parameter $CmdletParameterName"
	            continue
	        }
	        
	        if ($CmdletParameterName -eq 'Status') {
	            $Body[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName].value__
	        } else {
	            $Body[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName]
	        }
	    }
	    
	    $uri = BuildNewURI -Segments $uriSegments
	    
	    InvokeNetboxRequest -URI $uri -Method POST -Body $Body
	}
	
	function Add-NetboxVirtualInterface {
	    [CmdletBinding()]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [string]$Name,
	        
	        [Parameter(Mandatory = $true)]
	        [uint16]$Virtual_Machine,
	        
	        [boolean]$Enabled = $true,
	        
	        [string]$MAC_Address,
	        
	        [uint16]$MTU,
	        
	        [string]$Description,
	        
	        [switch]$Raw
	    )
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('virtualization', 'interfaces'))
	    
	    $Body = @{}
	    
	    if (-not $PSBoundParameters.ContainsKey('Enabled')) {
	        [void]$PSBoundParameters.Add('enabled', $Enabled)
	    }
	    
	    foreach ($CmdletParameterName in $PSBoundParameters.Keys) {
	        if ($CmdletParameterName -in $CommonParameterNames) {
	            # These are common parameters and should not be appended to the URI
	            Write-Debug "Skipping parameter $CmdletParameterName"
	            continue
	        }
	        
	        $Body[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName]
	    }
	    
	    $uri = BuildNewURI -Segments $uriSegments
	    
	    InvokeNetboxRequest -URI $uri -Method POST -Body $Body
	}
	
	
	
	#endregion ADD commands
	
	
	#endregion

#region Invoke-IPAM_ps1
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.150
		 Created on:   	5/10/2018 3:41 PM
		 Created by:   	Ben Claussen
		 Organization: 	NEOnet
		 Filename:     	IPAM.ps1
		===========================================================================
		.DESCRIPTION
			IPAM Object functions
	#>
	
	function Get-NetboxIPAMChoices {
	    [CmdletBinding()]
	    param ()
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('ipam', '_choices'))
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $Parameters
	    
	    InvokeNetboxRequest -URI $uri
	}
	
	function VerifyIPAMChoices {
	<#
	    .SYNOPSIS
	        Internal function to verify provided values for static choices
	    
	    .DESCRIPTION
	        When users connect to the API, choices for each major object are cached to the config variable. 
	        These values are then utilized to verify if the provided value from a user is valid.
	    
	    .PARAMETER ProvidedValue
	        The value to validate against static choices
	    
	    .PARAMETER AggregateFamily
	        Verify against aggregate family values
	    
	    .PARAMETER PrefixFamily
	        Verify against prefix family values
	    
	    .PARAMETER PrefixStatus
	        Verify against prefix status values
	    
	    .PARAMETER IPAddressFamily
	        Verify against ip-address family values
	    
	    .PARAMETER IPAddressStatus
	        Verify against ip-address status values
	    
	    .PARAMETER IPAddressRole
	        Verify against ip-address role values
	    
	    .PARAMETER VLANStatus
	        Verify against VLAN status values
	    
	    .PARAMETER ServiceProtocol
	        Verify against service protocol values
	    
	    .EXAMPLE
	        PS C:\> VerifyIPAMChoices -ProvidedValue 'loopback' -IPAddressRole
	    
	    .EXAMPLE
	        PS C:\> VerifyIPAMChoices -ProvidedValue 'Loopback' -IPAddressFamily
	                >> Invalid value Loopback for ip-address:family. Must be one of: 4, 6, IPv4, IPv6
	    
	    .FUNCTIONALITY
	        This cmdlet is intended to be used internally and not exposed to the user
	    
	    .OUTPUT
	        This function returns nothing if the value is valid. Otherwise, it will throw an error.
	#>
	    
	    [CmdletBinding()]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [object]$ProvidedValue,
	        
	        [Parameter(ParameterSetName = 'aggregate:family',
	                   Mandatory = $true)]
	        [switch]$AggregateFamily,
	        
	        [Parameter(ParameterSetName = 'prefix:family',
	                   Mandatory = $true)]
	        [switch]$PrefixFamily,
	        
	        [Parameter(ParameterSetName = 'prefix:status',
	                   Mandatory = $true)]
	        [switch]$PrefixStatus,
	        
	        [Parameter(ParameterSetName = 'ip-address:family',
	                   Mandatory = $true)]
	        [switch]$IPAddressFamily,
	        
	        [Parameter(ParameterSetName = 'ip-address:status',
	                   Mandatory = $true)]
	        [switch]$IPAddressStatus,
	        
	        [Parameter(ParameterSetName = 'ip-address:role',
	                   Mandatory = $true)]
	        [switch]$IPAddressRole,
	        
	        [Parameter(ParameterSetName = 'vlan:status',
	                   Mandatory = $true)]
	        [switch]$VLANStatus,
	        
	        [Parameter(ParameterSetName = 'service:protocol',
	                   Mandatory = $true)]
	        [switch]$ServiceProtocol
	    )
	    
	    $ValidValues = New-Object System.Collections.ArrayList
	    
	    [void]$ValidValues.AddRange($script:NetboxConfig.Choices.IPAM.$($PSCmdlet.ParameterSetName).value)
	    [void]$ValidValues.AddRange($script:NetboxConfig.Choices.IPAM.$($PSCmdlet.ParameterSetName).label)
	    
	    if ($ValidValues.Count -eq 0) {
	        throw "Missing valid values for $($PSCmdlet.ParameterSetName)"
	    }
	    
	    if ($ValidValues -inotcontains $ProvidedValue) {
	        throw "Invalid value '$ProvidedValue' for '$($PSCmdlet.ParameterSetName)'. Must be one of: $($ValidValues -join ', ')"
	    }
	    
	    # Convert the ProvidedValue to the integer value
	    try {
	        $intVal = [uint16]"$ProvidedValue"
	    } catch {
	        # It must not be a number, get the value from the label
	        $intVal = [uint16]$script:NetboxConfig.Choices.IPAM.$($PSCmdlet.ParameterSetName).Where({$_.Label -eq $ProvidedValue}).Value
	    }
	    
	    return $intVal
	}
	
	
	function Get-NetboxIPAMAggregate {
	    [CmdletBinding()]
	    param
	    (
	        [uint16]$Limit,
	        
	        [uint16]$Offset,
	        
	        [string]$Family,
	        
	        [datetime]$Date_Added,
	        
	        [uint16[]]$Id,
	        
	        [string]$Query,
	        
	        [uint16]$RIR_Id,
	        
	        [string]$RIR,
	        
	        [switch]$Raw
	    )
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('ipam', 'aggregates'))
	    
	    $URIParameters = @{}
	    
	    foreach ($CmdletParameterName in $PSBoundParameters.Keys) {
	        if ($CmdletParameterName -in $CommonParameterNames) {
	            # These are common parameters and should not be appended to the URI
	            Write-Debug "Skipping parameter $CmdletParameterName"
	            continue
	        }
	        
	        if ($CmdletParameterName -eq 'Id') {
	            # Check if there is one or more values for Id and build a URI or query as appropriate
	            if (@($PSBoundParameters[$CmdletParameterName]).Count -gt 1) {
	                $URIParameters['id__in'] = $Id -join ','
	            } else {
	                [void]$uriSegments.Add($PSBoundParameters[$CmdletParameterName])
	            }
	        } elseif ($CmdletParameterName -eq 'Query') {
	            $URIParameters['q'] = $PSBoundParameters[$CmdletParameterName]
	        } else {
	            $URIParameters[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName]
	        }
	    }
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $URIParameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	function Get-NetboxIPAMAddress {
	    [CmdletBinding()]
	    param
	    (
	        [uint16]$Limit,
	        
	        [uint16]$Offset,
	        
	        [object]$Family,
	        
	        [uint16[]]$Id,
	        
	        [string]$Query,
	        
	        [uint16]$Parent,
	        
	        [byte]$Mask_Length,
	        
	        [string]$VRF,
	        
	        [uint16]$VRF_Id,
	        
	        [string]$Tenant,
	        
	        [uint16]$Tenant_Id,
	        
	        [string]$Device,
	        
	        [uint16]$Device_ID,
	        
	        [string]$Virtual_Machine,
	        
	        [uint16]$Virtual_Machine_Id,
	        
	        [uint16]$Interface_Id,
	        
	        [object]$Status,
	        
	        [object]$Role,
	        
	        [switch]$Raw
	    )
	    
	    if ($Family) {
	        $PSBoundParameters.Family = VerifyIPAMChoices -ProvidedValue $Family -IPAddressFamily   
	    }
	    
	    if ($Status) {
	        $PSBoundParameters.Status = VerifyIPAMChoices -ProvidedValue $Status -IPAddressStatus
	    }
	    
	    if ($Role) {
	        $PSBoundParameters.Role = VerifyIPAMChoices -ProvidedValue $Role -IPAddressRole
	    }
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('ipam', 'ip-addresses'))
	    
	    $URIParameters = @{}
	    
	    foreach ($CmdletParameterName in $PSBoundParameters.Keys) {
	        if ($CmdletParameterName -in $CommonParameterNames) {
	            # These are common parameters and should not be appended to the URI
	            Write-Debug "Skipping parameter $CmdletParameterName"
	            continue
	        }
	        
	        if ($CmdletParameterName -eq 'Id') {
	            # Check if there is one or more values for Id and build a URI or query as appropriate
	            if (@($PSBoundParameters[$CmdletParameterName]).Count -gt 1) {
	                $URIParameters['id__in'] = $Id -join ','
	            } else {
	                [void]$uriSegments.Add($PSBoundParameters[$CmdletParameterName])
	            }
	        } elseif ($CmdletParameterName -eq 'Query') {
	            $URIParameters['q'] = $PSBoundParameters[$CmdletParameterName]
	        } else {
	            $URIParameters[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName]
	        }
	    }
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $URIParameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	function Get-NetboxIPAMAvaiableIP {
	<#
	    .SYNOPSIS
	        A convenience method for returning available IP addresses within a prefix
	    
	    .DESCRIPTION
	        By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit
	        (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated
	    
	    .PARAMETER Prefix_ID
	        A description of the Prefix_ID parameter.
	    
	    .PARAMETER NumberOfIPs
	        A description of the NumberOfIPs parameter.
	    
	    .EXAMPLE
	        PS C:\> Get-NetboxIPAMAvaiableIP -Prefix_ID $value1
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [uint16]$Prefix_ID,
	        
	        [uint16]$NumberOfIPs,
	        
	        [switch]$Raw
	    )
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('ipam', 'prefixes', $Prefix_ID, 'available-ips'))
	    
	    $uriParameters = @{}
	    
	    if ($NumberOfIPs) {
	        [void]$uriParameters.Add('limit', $NumberOfIPs)
	    }
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $uriParameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	function Get-NetboxIPAMPrefix {
	    [CmdletBinding()]
	    param
	    (
	        [uint16]$Limit,
	        
	        [uint16]$Offset,
	        
	        [object]$Family,
	        
	        [uint16[]]$Id,
	        
	        [string]$Query,
	        
	        #[string]$Within,
	
	        #[string]$Within_Include,
	
	        [string]$Contains,
	        
	        [byte]$Mask_Length,
	        
	        [string]$VRF,
	        
	        [uint16]$VRF_Id,
	        
	        [string]$Tenant,
	        
	        [uint16]$Tenant_Id,
	        
	        [string]$Site,
	        
	        [uint16]$Site_Id,
	        
	        [string]$Vlan_VId,
	        
	        [uint16]$Vlan_Id,
	        
	        [object]$Status,
	        
	        [string]$Role,
	        
	        [uint16]$Role_Id,
	        
	        [switch]$Raw
	    )
	    
	    if ($Family) {
	        $PSBoundParameters.Family = VerifyIPAMChoices -ProvidedValue $Family -PrefixFamily
	    }
	    
	    if ($Status) {
	        $PSBoundParameters.Status = VerifyIPAMChoices -ProvidedValue $Status -PrefixStatus
	    }
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('ipam', 'prefixes'))
	    
	    $URIParameters = @{}
	    
	    foreach ($CmdletParameterName in $PSBoundParameters.Keys) {
	        if ($CmdletParameterName -in $CommonParameterNames) {
	            # These are common parameters and should not be appended to the URI
	            Write-Debug "Skipping parameter $CmdletParameterName"
	            continue
	        }
	        
	        if ($CmdletParameterName -eq 'Id') {
	            # Check if there is one or more values for Id and build a URI or query as appropriate
	            if (@($PSBoundParameters[$CmdletParameterName]).Count -gt 1) {
	                $URIParameters['id__in'] = $Id -join ','
	            } else {
	                [void]$uriSegments.Add($PSBoundParameters[$CmdletParameterName])
	            }
	        } elseif ($CmdletParameterName -eq 'Query') {
	            $URIParameters['q'] = $PSBoundParameters[$CmdletParameterName]
	        } else {
	            $URIParameters[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName]
	        }
	    }
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $URIParameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	#endregion

# Build a list of common paramters so we can omit them to build URI parameters
$script:CommonParameterNames = New-Object System.Collections.ArrayList
[void]$script:CommonParameterNames.AddRange(@([System.Management.Automation.PSCmdlet]::CommonParameters))
[void]$script:CommonParameterNames.AddRange(@([System.Management.Automation.PSCmdlet]::OptionalCommonParameters))
[void]$script:CommonParameterNames.Add('Raw')

SetupNetboxConfigVariable

if (-not ([System.Management.Automation.PSTypeName]'NetboxVirtualMachineStatus').Type) {
    Add-Type -TypeDefinition @"
public enum NetboxVirtualMachineStatus
{
    Offline = 0,
    Active = 1,
    Staged = 3
}
"@
}


Export-ModuleMember -Function *
#Export-ModuleMember -Function *-*