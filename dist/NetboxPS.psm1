<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.152
     Generated on:       5/21/2018 3:34 PM
     Generated by:       Ben Claussen
     Organization:       NEOnet
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2018
#>


#region Invoke-Helpers_ps1
	<#	
	    .NOTES
	    ===========================================================================
	     Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.148
	     Created on:   	2/28/2018 3:33 PM
	     Created by:   	Ben Claussen
	     Organization: 	NEOnet
	     Filename:     	Helpers.ps1
	    ===========================================================================
	    .DESCRIPTION
	    	These function are internal functions and generally are not
	        exposed to the end user
	#>
	
	function CheckNetboxIsConnected {
		[CmdletBinding()]
	    param ()
	    
	    Write-Verbose "Checking connection status"
		if (-not $script:NetboxConfig.Connected) {
			throw "Not connected to a Netbox API! Please run 'Connect-NetboxAPI'"
	    }
	}
	
	function BuildNewURI {
	<#
	    .SYNOPSIS
	        Create a new URI for Netbox
	    
	    .DESCRIPTION
	        A detailed description of the BuildNewURI function.
	    
	    .PARAMETER Hostname
	        Hostname of the Netbox API
	    
	    .PARAMETER Segments
	        Array of strings for each segment in the URL path
	    
	    .PARAMETER Parameters
	        Hashtable of query parameters to include
	    
	    .PARAMETER HTTPS
	        Whether to use HTTPS or HTTP
	    
	    .PARAMETER Port
	        A description of the Port parameter.
	    
	    .PARAMETER APIInfo
	        A description of the APIInfo parameter.
	    
	    .EXAMPLE
	        PS C:\> BuildNewURI
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    [OutputType([System.UriBuilder])]
	    param
	    (
	        [Parameter(Mandatory = $false)]
	        [string]$Hostname,
	        
	        [Parameter(Mandatory = $false)]
	        [string[]]$Segments,
	        
	        [Parameter(Mandatory = $false)]
	        [hashtable]$Parameters,
	        
	        [Parameter(Mandatory = $false)]
	        [boolean]$HTTPS = $true,
	        
	        [ValidateRange(1, 65535)]
	        [uint16]$Port = 443,
	        
	        [switch]$SkipConnectedCheck
	    )
	    
	    Write-Verbose "Building URI"
	    
	    if (-not $SkipConnectedCheck) {
	        # There is no point in continuing if we have not successfully connected to an API
	        $null = CheckNetboxIsConnected
	    }
	    
	    if (-not $Hostname) {
	        $Hostname = Get-NetboxHostname
	    }
	    
	    if ($HTTPS) {
	        Write-Verbose " Setting scheme to HTTPS"
	        $Scheme = 'https'
	    } else {
	        Write-Warning " Connecting via non-secure HTTP is not-recommended"
	        
	        Write-Verbose " Setting scheme to HTTP"
	        $Scheme = 'http'
	        
	        if (-not $PSBoundParameters.ContainsKey('Port')) {
	            # Set the port to 80 if the user did not supply it
	            Write-Verbose " Setting port to 80 as default because it was not supplied by the user"
	            $Port = 80
	        }
	    }
	    
	    # Begin a URI builder with HTTP/HTTPS and the provided hostname
	    $uriBuilder = [System.UriBuilder]::new($Scheme, $Hostname, $Port)
	        
	    # Generate the path by trimming excess slashes and whitespace from the $segments[] and joining together
	    $uriBuilder.Path = "api/{0}/" -f ($Segments.ForEach({$_.trim('/').trim()}) -join '/')
	    
	    Write-Verbose " URIPath: $($uriBuilder.Path)"
	    
	    if ($parameters) {
	        # Loop through the parameters and use the HttpUtility to create a Query string
	        [System.Collections.Specialized.NameValueCollection]$URIParams = [System.Web.HttpUtility]::ParseQueryString([String]::Empty)
	        
	        foreach ($param in $Parameters.GetEnumerator()) {
	            Write-Verbose " Adding URI parameter $($param.Key):$($param.Value)"
	            $URIParams[$param.Key] = $param.Value
	        }
	        
	        $uriBuilder.Query = $URIParams.ToString()
	    }
	    
	    Write-Verbose " Completed building URIBuilder"
	    # Return the entire UriBuilder object
	    $uriBuilder
	}
	
	function BuildURIComponents {
	    [CmdletBinding()]
	    [OutputType([hashtable])]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [System.Collections.ArrayList]$URISegments,
	        
	        [Parameter(Mandatory = $true)]
	        [object]$ParametersDictionary,
	        
	        [string[]]$SkipParameterByName
	    )
	    
	    Write-Verbose "Building URI components"
	    
	    $URIParameters = @{}
	    
	    foreach ($CmdletParameterName in $ParametersDictionary.Keys) {
	        if ($CmdletParameterName -in $CommonParameterNames) {
	            # These are common parameters and should not be appended to the URI
	            Write-Debug "Skipping parameter $CmdletParameterName"
	            continue
	        }
	        
	        if ($CmdletParameterName -in $SkipParameterByName) {
	            Write-Debug "Skipping parameter $CmdletParameterName"
	            continue
	        }
	        
	        if ($CmdletParameterName -eq 'Id') {
	            # Check if there is one or more values for Id and build a URI or query as appropriate
	            if (@($ParametersDictionary[$CmdletParameterName]).Count -gt 1) {
	                Write-Verbose " Joining IDs for parameter"
	                $URIParameters['id__in'] = $ParametersDictionary[$CmdletParameterName] -join ','
	            } else {
	                Write-Verbose " Adding ID to segments"
	                [void]$uriSegments.Add($ParametersDictionary[$CmdletParameterName])
	            }
	        } elseif ($CmdletParameterName -eq 'Query') {
	            Write-Verbose " Adding query parameter"
	            $URIParameters['q'] = $ParametersDictionary[$CmdletParameterName]
	        } else {
	            Write-Verbose " Adding $($CmdletParameterName.ToLower()) parameter"
	            $URIParameters[$CmdletParameterName.ToLower()] = $ParametersDictionary[$CmdletParameterName]
	        }
	    }
	    
	    return @{
	        'Segments' = [System.Collections.ArrayList]$URISegments
	        'Parameters' = $URIParameters
	    }
	}
	
	function GetChoiceValidValues {
	    [CmdletBinding()]
	    [OutputType([System.Collections.ArrayList])]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [string]$MajorObject,
	        
	        [Parameter(Mandatory = $true)]
	        [object]$Choice
	    )
	    
	    $ValidValues = New-Object System.Collections.ArrayList
	    
	    if (-not $script:NetboxConfig.Choices.$MajorObject.$Choice) {
	        throw "Missing choices for $Choice"
	    }
	    
	    [void]$ValidValues.AddRange($script:NetboxConfig.Choices.$MajorObject.$Choice.value)
	    [void]$ValidValues.AddRange($script:NetboxConfig.Choices.$MajorObject.$Choice.label)
	    
	    if ($ValidValues.Count -eq 0) {
	        throw "Missing valid values for $MajorObject.$Choice"
	    }
	    
	    return [System.Collections.ArrayList]$ValidValues
	}
	
	function ValidateChoice {
	    [CmdletBinding()]
	    [OutputType([uint16])]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [ValidateSet('Circuits', 'Extras', 'IPAM', 'Virtualization', IgnoreCase = $true)]
	        [string]$MajorObject,
	        
	        [Parameter(Mandatory = $true)]
	        [string]$ChoiceName,
	        
	        [Parameter(Mandatory = $true)]
	        [object]$ProvidedValue
	    )
	    
	    $ValidValues = GetChoiceValidValues -MajorObject $MajorObject -Choice $ChoiceName
	    
	    Write-Verbose "Validating $ChoiceName"
	    Write-Verbose "Checking '$ProvidedValue' against [$($ValidValues -join ', ')]"
	    
	    if ($ValidValues -inotcontains $ProvidedValue) {
	        throw "Invalid value '$ProvidedValue' for '$ChoiceName'. Must be one of: $($ValidValues -join ', ')"
	    }
	    
	    # Convert the ProvidedValue to the integer value
	    try {
	        $intVal = [uint16]"$ProvidedValue"
	    } catch {
	        # It must not be a number, get the value from the label
	        $intVal = [uint16]$script:NetboxConfig.Choices.$MajorObject.$ChoiceName.Where({
	                $_.Label -eq $ProvidedValue
	            }).Value
	    }
	    
	    return $intVal
	}
	
	
	function GetNetboxAPIErrorBody {
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [System.Net.HttpWebResponse]$Response
	    )
	    
	    # This takes the $Response stream and turns it into a useable object... generally a string.
	    # If the body is JSON, you should be able to use ConvertFrom-Json
	    
	    $reader = New-Object System.IO.StreamReader($Response.GetResponseStream())
	    $reader.BaseStream.Position = 0
	    $reader.DiscardBufferedData()
	    $reader.ReadToEnd()
	}
	
	function InvokeNetboxRequest {
	    [CmdletBinding()]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [System.UriBuilder]$URI,
	        
	        [Hashtable]$Headers = @{},
	        
	        [pscustomobject]$Body = $null,
	        
	        [ValidateRange(0, 60)]
	        [uint16]$Timeout = 5,
	        
	        [ValidateSet('GET', 'PATCH', 'PUT', 'POST', 'DELETE', IgnoreCase = $true)]
	        [string]$Method = 'GET',
	        
	        [switch]$Raw
	    )
	    
	    $creds = Get-NetboxCredential
	    
	    $Headers.Authorization = "Token {0}" -f $creds.GetNetworkCredential().Password
	    
	    $splat = @{
	        'Method' = $Method
	        'Uri' = $URI.Uri.AbsoluteUri # This property auto generates the scheme, hostname, path, and query
	        'Headers' = $Headers
	        'TimeoutSec' = $Timeout
	        'ContentType' = 'application/json'
	        'ErrorAction' = 'Stop'
	        'Verbose' = $VerbosePreference
	    }
	    
	    if ($Body) {
	        Write-Verbose "BODY: $($Body | ConvertTo-Json -Compress)"
	        $null = $splat.Add('Body', ($Body | ConvertTo-Json -Compress))
	    }
	    
	    $result = Invoke-RestMethod @splat
	    
	    #region TODO: Handle errors a little more gracefully...
	    
	    <#
	    try {
	        Write-Verbose "Sending request..."
	        $result = Invoke-RestMethod @splat
	        Write-Verbose $result
	    } catch {
	        Write-Verbose "Caught exception"
	        if ($_.Exception.psobject.properties.Name.contains('Response')) {
	            Write-Verbose "Exception contains a response property"
	            if ($Raw) {
	                Write-Verbose "RAW provided...throwing raw exception"
	                throw $_
	            }
	            
	            Write-Verbose "Converting response to object"
	            $myError = GetNetboxAPIErrorBody -Response $_.Exception.Response | ConvertFrom-Json
	        } else {
	            Write-Verbose "No response property found"
	            $myError = $_
	        }
	    }
	    
	    Write-Verbose "MyError is $($myError.GetType().FullName)"
	    
	    if ($myError -is [Exception]) {
	        throw $_
	    } elseif ($myError -is [pscustomobject]) {
	        throw $myError.detail
	    }    
	    #>
	    
	    #endregion TODO: Handle errors a little more gracefully...
	    
	    # If the user wants the raw value from the API... otherwise return only the actual result
	    if ($Raw) {
	        Write-Verbose "Returning raw result by choice"
	        return $result
	    } else {
	        if ($result.psobject.Properties.Name.Contains('results')) {
	            Write-Verbose "Found Results property on data, returning results directly"
	            return $result.Results
	        } else {
	            Write-Verbose "Did NOT find results property on data, returning raw result"
	            return $result
	        }
	    }
	}
	
	
	
	
	#region Troubleshooting commands
	
	function ThrowNetboxRESTError {
	    $uriSegments = [System.Collections.ArrayList]::new(@('fake', 'url'))
	    
	    $URIParameters = @{}
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $URIParameters
	    
	    InvokeNetboxRequest -URI $uri -Raw
	}
	
	function CreateEnum {
	    [CmdletBinding()]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [string]$EnumName,
	        
	        [Parameter(Mandatory = $true)]
	        [pscustomobject]$Values,
	        
	        [switch]$PassThru
	    )
	    
	    $definition = @"
public enum $EnumName
{`n$(foreach ($value in $values) {"`t$($value.label) = $($value.value),`n"})
}
"@
	    if (-not ([System.Management.Automation.PSTypeName]"$EnumName").Type) {
	        #Write-Host $definition -ForegroundColor Green
	        Add-Type -TypeDefinition $definition -PassThru:$PassThru
	    } else {
	        Write-Warning "EnumType $EnumName already exists."
	    }
	}
	
	#endregion Troubleshooting commands
	
	
	
	
	
	
	#endregion

#region Invoke-Setup_ps1
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.148
		 Created on:   	2/28/2018 3:33 PM
		 Created by:   	Ben Claussen
		 Organization: 	NEOnet
		 Filename:     	Setup.ps1
		===========================================================================
		.DESCRIPTION
			These are the function used to setup the environment for connecting
	        to a Netbox API
	#>
	
	function SetupNetboxConfigVariable {
	    [CmdletBinding()]
	    param
	    (
	        [switch]$Overwrite
	    )
	    
	    Write-Verbose "Checking for NetboxConfig hashtable"
	    if ((-not ($script:NetboxConfig)) -or $Overwrite) {
	        Write-Verbose "Creating NetboxConfig hashtable"
	        $script:NetboxConfig = @{
	            'Connected' = $false
	            'Choices' = @{}
	        }
	    }
	    
	    Write-Verbose "NetboxConfig hashtable already exists"
	}
	
	function GetNetboxConfigVariable {
	    return $script:NetboxConfig
	}
	
	function Set-NetboxHostName {
	    [CmdletBinding(ConfirmImpact = 'Low',
	                   SupportsShouldProcess = $true)]
	    [OutputType([string])]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [string]$Hostname
	    )
	    
	    if ($PSCmdlet.ShouldProcess('Netbox Hostname', 'Set')) {
	        $script:NetboxConfig.Hostname = $Hostname.Trim()
	        $script:NetboxConfig.Hostname
	    }
	}
	
	function Get-NetboxHostname {
		[CmdletBinding()]
		param ()
	    
	    Write-Verbose "Getting Netbox hostname"
		if ($null -eq $script:NetboxConfig.Hostname) {
			throw "Netbox Hostname is not set! You may set it with Set-NetboxHostname -Hostname 'hostname.domain.tld'"
		}
		
		$script:NetboxConfig.Hostname
	}
	
	function Set-NetboxCredential {
	    [CmdletBinding(DefaultParameterSetName = 'CredsObject',
	                   ConfirmImpact = 'Low',
	                   SupportsShouldProcess = $true)]
	    [OutputType([pscredential])]
	    param
	    (
	        [Parameter(ParameterSetName = 'CredsObject',
	                   Mandatory = $true)]
	        [pscredential]$Credential,
	        
	        [Parameter(ParameterSetName = 'UserPass',
	                   Mandatory = $true)]
	        [securestring]$Token
	    )
	    
	    if ($PSCmdlet.ShouldProcess('Netbox Credentials', 'Set')) {
	        switch ($PsCmdlet.ParameterSetName) {
	            'CredsObject' {
	                $script:NetboxConfig.Credential = $Credential
	                break
	            }
	            
	            'UserPass' {
	                $script:NetboxConfig.Credential = [System.Management.Automation.PSCredential]::new('notapplicable', $Token)
	                break
	            }
	        }
	        
	        $script:NetboxConfig.Credential
	    }
	}
	
	function Get-NetboxCredential {
		[CmdletBinding()]
		[OutputType([pscredential])]
		param ()
		
		if (-not $script:NetboxConfig.Credential) {
			throw "Netbox Credentials not set! You may set with Set-NetboxCredential"
		}
		
		$script:NetboxConfig.Credential
	}
	
	function VerifyAPIConnectivity {
	    [CmdletBinding()]
	    param ()
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('extras', '_choices'))
	    
	    $uri = BuildNewURI -Segments $uriSegments -SkipConnectedCheck
	    
	    InvokeNetboxRequest -URI $uri
	}
	
	function Connect-NetboxAPI {
	<#
	    .SYNOPSIS
	        Connects to the Netbox API and ensures Credential work properly
	    
	    .DESCRIPTION
	        A detailed description of the Connect-NetboxAPI function.
	    
	    .PARAMETER Hostname
	        A description of the Hostname parameter.
	    
	    .PARAMETER Credential
	        A description of the Credential parameter.
	    
	    .EXAMPLE
	        PS C:\> Connect-NetboxAPI -Hostname "netbox.domain.com"
	        
	        This will prompt for Credential, then proceed to attempt a connection to Netbox
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [string]$Hostname,
	        
	        [Parameter(Mandatory = $false)]
	        [pscredential]$Credential
	    )
	    
	    if (-not $Credential) {
	        try {
	            $Credential = Get-NetboxCredential -ErrorAction Stop
	        } catch {
	            # Credentials are not set... Try to obtain from the user
	            if (-not ($Credential = Get-Credential -UserName 'username-not-applicable' -Message "Enter token for Netbox")) {
	                throw "Token is necessary to connect to a Netbox API."
	            }
	        }
	    }
	    
	    $null = Set-NetboxHostName -Hostname $Hostname
	    $null = Set-NetboxCredential -Credential $Credential
	    
	    try {
	        Write-Verbose "Verifying API connectivity..."
	        $null = VerifyAPIConnectivity
	        $script:NetboxConfig.Connected = $true
	        Write-Verbose "Successfully connected!"
	    } catch {
	        Write-Verbose "Failed to connect. Generating error"
	        Write-Verbose $_.Exception.Message
	        if (($_.Exception.Response) -and ($_.Exception.Response.StatusCode -eq 403)) {
	            throw "Invalid token"
	        } else {
	            throw $_
	        }
	    }
	    
	    Write-Verbose "Caching static choices"
	    $script:NetboxConfig.Choices.Circuits = Get-NetboxCircuitsChoices
	    #$script:NetboxConfig.Choices.DCIM = Get-NetboxDCIMChoices          # Not completed yet
	    $script:NetboxConfig.Choices.Extras = Get-NetboxExtrasChoices
	    $script:NetboxConfig.Choices.IPAM = Get-NetboxIPAMChoices
	    #$script:NetboxConfig.Choices.Secrets = Get-NetboxSecretsChoices    # Not completed yet
	    #$script:NetboxConfig.Choices.Tenancy = Get-NetboxTenancyChoices    # Not completed yet
	    $script:NetboxConfig.Choices.Virtualization = Get-NetboxVirtualizationChoices
	    
	    Write-Verbose "Connection process completed"
	}
	
	
	
	
	
	
	
	
	
	#endregion

#region Invoke-Extras_ps1
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.148
		 Created on:   	2/28/2018 3:43 PM
		 Created by:   	Ben Claussen
		 Organization: 	NEOnet
		 Filename:     	Extras.ps1
		===========================================================================
		.DESCRIPTION
			Extras objects functions
	#>
	
	function Get-NetboxExtrasChoices {
	    [CmdletBinding()]
	    [Diagnostics.CodeAnalysis.SuppressMessageAttribute("PSUseSingularNouns", "", Justification = "These are literally 'choices' in Netbox")]
		param ()
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('extras', '_choices'))
	    
	    $uri = BuildNewURI -Segments $uriSegments
	    
	    InvokeNetboxRequest -URI $uri
	}
	#endregion

#region Invoke-Circuits_ps1
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.148
		 Created on:   	2/28/2018 4:06 PM
		 Created by:   	Ben Claussen
		 Organization: 	NEOnet
		 Filename:     	Circuits.ps1
		===========================================================================
		.DESCRIPTION
			Circuit object functions
	#>
	
	function Get-NetboxCircuitsChoices {
	<#
		.SYNOPSIS
			Gets the choices associated with circuits
		
		.DESCRIPTION
			A detailed description of the Get-NetboxCircuitsChoices function.
		
		.EXAMPLE
					PS C:\> Get-NetboxCircuitsChoices
		
		.NOTES
			Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    [Diagnostics.CodeAnalysis.SuppressMessageAttribute("PSUseSingularNouns", "", Justification = "These are literally 'choices' in Netbox")]
		param ()
		
		$uriSegments = [System.Collections.ArrayList]::new(@('circuits', '_choices'))
		$uri = BuildNewURI -Segments $uriSegments
		
		InvokeNetboxRequest -URI $uri
	}
	
	function Get-NetboxCircuit {
	<#
		.SYNOPSIS
			Gets one or more circuits
		
		.DESCRIPTION
			A detailed description of the Get-NetboxCircuit function.
		
		.PARAMETER CID
			Circuit ID
		
		.PARAMETER InstallDate
			Date of installation
		
		.PARAMETER CommitRate
			Committed rate in Kbps
		
		.PARAMETER Query
			A raw search query... As if you were searching the web site
		
		.PARAMETER Provider
			The name or ID of the provider. Provide either [string] or [int]. String will search provider names, integer will search database IDs
		
		.PARAMETER Type
			Type of circuit. Provide either [string] or [int]. String will search provider type names, integer will search database IDs
		
		.PARAMETER Site
			Location/site of circuit. Provide either [string] or [int]. String will search site names, integer will search database IDs
		
		.PARAMETER Tenant
			Tenant assigned to circuit. Provide either [string] or [int]. String will search tenant names, integer will search database IDs
		
		.PARAMETER Id
			Database ID of circuit. This will query for exactly the IDs provided
		
		.PARAMETER ID__IN
			Multiple unique DB IDs to retrieve
		
		.EXAMPLE
			PS C:\> Get-NetboxCircuit
		
		.NOTES
			Additional information about the function.
	#>
		
		[CmdletBinding()]
		param
		(
			[string]$CID,
			
			[datetime]$InstallDate,
			
			[uint32]$CommitRate,
			
			[string]$Query,
			
			[object]$Provider,
			
			[object]$Type,
			
			[string]$Site,
			
			[string]$Tenant,
			
			[uint16[]]$Id
		)
		
		#TODO: Place script here
	}
	#endregion

#region Invoke-Virtualization_ps1
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.150
		 Created on:   	5/8/2018 3:59 PM
		 Created by:   	Ben Claussen
		 Organization: 	NEOnet
		 Filename:     	Virtualization.ps1
		===========================================================================
		.DESCRIPTION
			Virtualization object functions
	#>
	
	function ValidateVirtualizationChoices {
	<#
	    .SYNOPSIS
	        Internal function to verify provided values for static choices
	    
	    .DESCRIPTION
	        When users connect to the API, choices for each major object are cached to the config variable. 
	        These values are then utilized to verify if the provided value from a user is valid.
	    
	    .PARAMETER ProvidedValue
	        The value to validate against static choices
	    
	    .PARAMETER AggregateFamily
	        Verify against aggregate family values
	    
	    .PARAMETER PrefixFamily
	        Verify against prefix family values
	    
	    .PARAMETER PrefixStatus
	        Verify against prefix status values
	    
	    .PARAMETER IPAddressFamily
	        Verify against ip-address family values
	    
	    .PARAMETER IPAddressStatus
	        Verify against ip-address status values
	    
	    .PARAMETER IPAddressRole
	        Verify against ip-address role values
	    
	    .PARAMETER VLANStatus
	        Verify against VLAN status values
	    
	    .PARAMETER ServiceProtocol
	        Verify against service protocol values
	    
	    .EXAMPLE
	        PS C:\> VerifyIPAMChoices -ProvidedValue 'loopback' -IPAddressRole
	    
	    .EXAMPLE
	        PS C:\> VerifyIPAMChoices -ProvidedValue 'Loopback' -IPAddressFamily
	                >> Invalid value Loopback for ip-address:family. Must be one of: 4, 6, IPv4, IPv6
	    
	    .FUNCTIONALITY
	        This cmdlet is intended to be used internally and not exposed to the user
	    
	    .OUTPUT
	        This function returns nothing if the value is valid. Otherwise, it will throw an error.
	#>
	    
	    [CmdletBinding()]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [object]$ProvidedValue,
	        
	        [Parameter(ParameterSetName = 'virtual-machine:status',
	                   Mandatory = $true)]
	        [switch]$VirtualMachineStatus
	    )
	        
	    ValidateChoice -MajorObject 'Virtualization' -ChoiceName $PSCmdlet.ParameterSetName -ProvidedValue $ProvidedValue
	}
	
	#region GET commands
	
	function Get-NetboxVirtualizationChoices {
	    [CmdletBinding()]
	    [Diagnostics.CodeAnalysis.SuppressMessageAttribute("PSUseSingularNouns", "", Justification = "These are literally 'choices' in Netbox")]
	    param ()
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('virtualization', '_choices'))
	    
	    $uri = BuildNewURI -Segments $uriSegments
	    
	    InvokeNetboxRequest -URI $uri
	}
	
	function Get-NetboxVirtualMachine {
	<#
	    .SYNOPSIS
	        Obtains virtual machines from Netbox.
	    
	    .DESCRIPTION
	        Obtains one or more virtual machines based on provided filters.
	    
	    .PARAMETER Limit
	        Number of results to return per page
	    
	    .PARAMETER Offset
	        The initial index from which to return the results
	    
	    .PARAMETER Query
	        A general query used to search for a VM
	    
	    .PARAMETER Name
	        Name of the VM
	    
	    .PARAMETER Id
	        Database ID of the VM
	    
	    .PARAMETER Status
	        Status of the VM
	    
	    .PARAMETER Tenant
	        String value of tenant
	    
	    .PARAMETER Tenant_ID
	        Database ID of the tenant.
	    
	    .PARAMETER Platform
	        String value of the platform
	    
	    .PARAMETER Platform_ID
	        Database ID of the platform
	    
	    .PARAMETER Cluster_Group
	        String value of the cluster group.
	    
	    .PARAMETER Cluster_Group_Id
	        Database ID of the cluster group.
	    
	    .PARAMETER Cluster_Type
	        String value of the Cluster type.
	    
	    .PARAMETER Cluster_Type_Id
	        Database ID of the cluster type.
	    
	    .PARAMETER Cluster_Id
	        Database ID of the cluster.
	    
	    .PARAMETER Site
	        String value of the site.
	    
	    .PARAMETER Site_Id
	        Database ID of the site.
	    
	    .PARAMETER Role
	        String value of the role.
	    
	    .PARAMETER Role_Id
	        Database ID of the role.
	    
	    .PARAMETER Raw
	        A description of the Raw parameter.
	    
	    .PARAMETER TenantID
	        Database ID of tenant
	    
	    .PARAMETER PlatformID
	        Database ID of the platform
	    
	    .PARAMETER id__in
	        Database IDs of VMs
	    
	    .EXAMPLE
	        PS C:\> Get-NetboxVirtualMachine
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    param
	    (
	        [uint16]$Limit,
	        
	        [uint16]$Offset,
	        
	        [Alias('q')]
	        [string]$Query,
	        
	        [string]$Name,
	        
	        [uint16[]]$Id,
	        
	        [object]$Status,
	        
	        [string]$Tenant,
	        
	        [uint16]$Tenant_ID,
	        
	        [string]$Platform,
	        
	        [uint16]$Platform_ID,
	        
	        [string]$Cluster_Group,
	        
	        [uint16]$Cluster_Group_Id,
	        
	        [string]$Cluster_Type,
	        
	        [uint16]$Cluster_Type_Id,
	        
	        [uint16]$Cluster_Id,
	        
	        [string]$Site,
	        
	        [uint16]$Site_Id,
	        
	        [string]$Role,
	        
	        [uint16]$Role_Id,
	        
	        [switch]$Raw
	    )
	    
	    if ($null -ne $Status) {
	        $PSBoundParameters.Status = ValidateVirtualizationChoices -ProvidedValue $Status -VirtualMachineStatus
	    }
	    
	    $Segments = [System.Collections.ArrayList]::new(@('virtualization', 'virtual-machines'))
	    
	    $URIComponents = BuildURIComponents -URISegments $Segments -ParametersDictionary $PSBoundParameters
	    
	    $uri = BuildNewURI -Segments $URIComponents.Segments -Parameters $URIComponents.Parameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	function Get-NetboxVirtualMachineInterface {
	<#
	    .SYNOPSIS
	        Gets VM interfaces
	    
	    .DESCRIPTION
	        Obtains the interface objects for one or more VMs
	    
	    .PARAMETER Limit
	        Number of results to return per page.
	    
	    .PARAMETER Offset
	        The initial index from which to return the results.
	    
	    .PARAMETER Id
	        Database ID of the interface
	    
	    .PARAMETER Name
	        Name of the interface
	    
	    .PARAMETER Enabled
	        True/False if the interface is enabled
	    
	    .PARAMETER MTU
	        Maximum Transmission Unit size. Generally 1500 or 9000
	    
	    .PARAMETER Virtual_Machine_Id
	        ID of the virtual machine to which the interface(s) are assigned.
	    
	    .PARAMETER Virtual_Machine
	        Name of the virtual machine to get interfaces
	    
	    .PARAMETER MAC_Address
	        MAC address assigned to the interface
	    
	    .PARAMETER Raw
	        A description of the Raw parameter.
	    
	    .EXAMPLE
	        PS C:\> Get-NetboxVirtualMachineInterface
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    param
	    (
	        [uint16]$Limit,
	        
	        [uint16]$Offset,
	        
	        [Parameter(ValueFromPipeline = $true)]
	        [uint16]$Id,
	        
	        [string]$Name,
	        
	        [boolean]$Enabled,
	        
	        [uint16]$MTU,
	        
	        [uint16]$Virtual_Machine_Id,
	        
	        [string]$Virtual_Machine,
	        
	        [string]$MAC_Address,
	        
	        [switch]$Raw
	    )
	    
	    $Segments = [System.Collections.ArrayList]::new(@('virtualization', 'interfaces'))
	    
	    $URIComponents = BuildURIComponents -URISegments $Segments -ParametersDictionary $PSBoundParameters
	    
	    $uri = BuildNewURI -Segments $URIComponents.Segments -Parameters $URIComponents.Parameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	function Get-NetboxVirtualizationCluster {
	<#
	    .SYNOPSIS
	        Obtains virtualization clusters from Netbox.
	    
	    .DESCRIPTION
	        Obtains one or more virtualization clusters based on provided filters.
	    
	    .PARAMETER Limit
	        Number of results to return per page
	    
	    .PARAMETER Offset
	        The initial index from which to return the results
	    
	    .PARAMETER Query
	        A general query used to search for a cluster
	    
	    .PARAMETER Name
	        Name of the cluster
	    
	    .PARAMETER Id
	        Database ID(s) of the cluster
	    
	    .PARAMETER Group
	        String value of the cluster group.
	    
	    .PARAMETER Group_Id
	        Database ID of the cluster group.
	    
	    .PARAMETER Type
	        String value of the Cluster type.
	    
	    .PARAMETER Type_Id
	        Database ID of the cluster type.
	    
	    .PARAMETER Site
	        String value of the site.
	    
	    .PARAMETER Site_Id
	        Database ID of the site.
	    
	    .PARAMETER Raw
	        A description of the Raw parameter.
	    
	    .EXAMPLE
	        PS C:\> Get-NetboxVirtualizationCluster
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    param
	    (
	        [uint16]$Limit,
	        
	        [uint16]$Offset,
	        
	        [Alias('q')]
	        [string]$Query,
	        
	        [string]$Name,
	        
	        [Alias('id__in')]
	        [uint16[]]$Id,
	        
	        [string]$Group,
	        
	        [uint16]$Group_Id,
	        
	        [string]$Type,
	        
	        [uint16]$Type_Id,
	        
	        [string]$Site,
	        
	        [uint16]$Site_Id,
	        
	        [switch]$Raw
	    )
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('virtualization', 'clusters'))
	    
	    $URIParameters = @{
	    }
	    
	    foreach ($CmdletParameterName in $PSBoundParameters.Keys) {
	        if ($CmdletParameterName -in $CommonParameterNames) {
	            # These are common parameters and should not be appended to the URI
	            Write-Debug "Skipping parameter $CmdletParameterName"
	            continue
	        }
	        
	        if ($CmdletParameterName -eq 'Id') {
	            # Check if there is one or more values for Id and build a URI or query as appropriate
	            if (@($PSBoundParameters[$CmdletParameterName]).Count -gt 1) {
	                $URIParameters['id__in'] = $Id -join ','
	            } else {
	                [void]$uriSegments.Add($PSBoundParameters[$CmdletParameterName])
	            }
	        } elseif ($CmdletParameterName -eq 'Query') {
	            $URIParameters['q'] = $PSBoundParameters[$CmdletParameterName]
	        } else {
	            $URIParameters[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName]
	        }
	    }
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $URIParameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	function Get-NetboxVirtualizationClusterGroup {
	    [CmdletBinding()]
	    param
	    (
	        [uint16]$Limit,
	        
	        [uint16]$Offset,
	        
	        [string]$Name,
	        
	        [string]$Slug,
	        
	        [switch]$Raw
	    )
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('virtualization', 'cluster-groups'))
	    
	    $URIParameters = @{}
	    
	    foreach ($CmdletParameterName in $PSBoundParameters.Keys) {
	        if ($CmdletParameterName -in $CommonParameterNames) {
	            # These are common parameters and should not be appended to the URI
	            Write-Debug "Skipping parameter $CmdletParameterName"
	            continue
	        }
	        
	        $URIParameters[$CmdletParameterName.ToLower()] = $PSBoundParameters[$CmdletParameterName]
	    }
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $URIParameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	#endregion GET commands
	
	
	#region ADD/NEW commands
	
	function New-NetboxVirtualMachine {
	    [CmdletBinding()]
	    [OutputType([pscustomobject])]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [string]$Name,
	        
	        [Parameter(Mandatory = $true)]
	        [uint16]$Cluster,
	        
	        [uint16]$Tenant,
	        
	        [object]$Status = 'Active',
	        
	        [uint16]$Role,
	        
	        [uint16]$Platform,
	        
	        [uint16]$vCPUs,
	        
	        [uint16]$Memory,
	        
	        [uint16]$Disk,
	        
	        [hashtable]$Custom_Fields,
	        
	        [string]$Comments
	    )
	    
	    $PSBoundParameters.Status = ValidateVirtualizationChoices -ProvidedValue $Status -VirtualMachineStatus
	    
	    $Segments = [System.Collections.ArrayList]::new(@('virtualization', 'virtual-machines'))
	    
	    $URIComponents = BuildURIComponents -URISegments $Segments -ParametersDictionary $PSBoundParameters
	    
	    $URI = BuildNewURI -Segments $URIComponents.Segments
	    
	    InvokeNetboxRequest -URI $URI -Method POST -Body $URIComponents.Parameters
	}
	
	function Add-NetboxVirtualInterface {
	    [CmdletBinding()]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [string]$Name,
	        
	        [Parameter(Mandatory = $true)]
	        [uint16]$Virtual_Machine,
	        
	        [boolean]$Enabled = $true,
	        
	        [string]$MAC_Address,
	        
	        [uint16]$MTU,
	        
	        [string]$Description,
	        
	        [switch]$Raw
	    )
	    
	    $Segments = [System.Collections.ArrayList]::new(@('virtualization', 'interfaces'))
	    
	    $PSBoundParameters.Enabled = $Enabled
	    
	    $URIComponents = BuildURIComponents -URISegments $Segments -ParametersDictionary $PSBoundParameters
	    
	    $uri = BuildNewURI -Segments $URIComponents.Segments
	    
	    InvokeNetboxRequest -URI $uri -Method POST -Body $URIComponents.Parameters
	}
	
	#endregion ADD commands
	
	
	#region SET commands
	
	function Set-NetboxVirtualMachine {
	    [CmdletBinding(ConfirmImpact = 'High',
	                   SupportsShouldProcess = $true)]
	    param
	    (
	        [Parameter(Mandatory = $true,
	                   ValueFromPipelineByPropertyName = $true)]
	        [uint16]$Id,
	        
	        [string]$Name,
	        
	        [uint16]$Role,
	        
	        [uint16]$Cluster,
	        
	        [object]$Status,
	        
	        [uint16]$Platform,
	        
	        [uint16]$Primary_IPv4,
	        
	        [uint16]$Primary_IPv6,
	        
	        [byte]$VCPUs,
	        
	        [uint16]$Memory,
	        
	        [uint16]$Disk,
	        
	        [uint16]$Tenant,
	        
	        [string]$Comments,
	        
	        [hashtable]$Custom_Fields,
	        
	        [switch]$Force
	    )
	    
	    if ($null -ne $Status) {
	        $PSBoundParameters.Status = ValidateVirtualizationChoices -ProvidedValue $Status -VirtualMachineStatus
	    }
	    
	    $Segments = [System.Collections.ArrayList]::new(@('virtualization', 'virtual-machines', $Id))
	    
	    Write-Verbose "Obtaining VM from ID $Id"
	    
	    $CurrentVM = Get-NetboxVirtualMachine -Id $Id -ErrorAction Stop
	    
	    Write-Verbose "Finished obtaining VM"
	    
	    if ($Force -or $pscmdlet.ShouldProcess($CurrentVM.Name, "Set")) {
	        $URIComponents = BuildURIComponents -URISegments $Segments -ParametersDictionary $PSBoundParameters -SkipParameterByName 'Id', 'Force'
	        
	        $URI = BuildNewURI -Segments $URIComponents.Segments
	        
	        InvokeNetboxRequest -URI $URI -Body $URIComponents.Parameters -Method PATCH
	    }
	}
	
	function Set-NetboxVirtualMachineInterface {
	    [CmdletBinding(ConfirmImpact = 'Medium',
	                   SupportsShouldProcess = $true)]
	    [OutputType([pscustomobject])]
	    param
	    (
	        [Parameter(Mandatory = $true,
	                   ValueFromPipelineByPropertyName = $true)]
	        [uint16[]]$Id,
	        
	        [string]$Name,
	        
	        [string]$MAC_Address,
	        
	        [uint16]$MTU,
	        
	        [string]$Description,
	        
	        [boolean]$Enabled,
	        
	        [uint16]$Virtual_Machine,
	        
	        [switch]$Force
	    )
	    
	    begin {
	        
	    }
	    
	    process {
	        foreach ($VMI_ID in $Id) {
	            Write-Verbose "Obtaining VM Interface..."
	            $CurrentVMI = Get-NetboxVirtualMachineInterface -Id $VMI_ID -ErrorAction Stop
	            Write-Verbose "Finished obtaining VM Interface"
	            
	            $Segments = [System.Collections.ArrayList]::new(@('virtualization', 'interfaces', $CurrentVMI.Id))
	            
	            if ($Force -or $pscmdlet.ShouldProcess("Interface $($CurrentVMI.Id) on VM $($CurrentVMI.Virtual_Machine.Name)", "Set")) {
	                $URIComponents = BuildURIComponents -URISegments $Segments -ParametersDictionary $PSBoundParameters -SkipParameterByName 'Id', 'Force'
	                
	                $URI = BuildNewURI -Segments $URIComponents.Segments
	                
	                InvokeNetboxRequest -URI $URI -Body $URIComponents.Parameters -Method PATCH
	            }
	        }
	    }
	    
	    end {
	        
	    }
	}
	
	
	
	#endregion SET commands#endregion

#region Invoke-IPAM_ps1
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.150
		 Created on:   	5/10/2018 3:41 PM
		 Created by:   	Ben Claussen
		 Organization: 	NEOnet
		 Filename:     	IPAM.ps1
		===========================================================================
		.DESCRIPTION
			IPAM Object functions
	#>
	
	function Get-NetboxIPAMChoices {
	    [CmdletBinding()]
	    [Diagnostics.CodeAnalysis.SuppressMessageAttribute("PSUseSingularNouns", "", Justification = "These are literally 'choices' in Netbox")]
	    param ()
	    
	    $uriSegments = [System.Collections.ArrayList]::new(@('ipam', '_choices'))
	    
	    $uri = BuildNewURI -Segments $uriSegments -Parameters $Parameters
	    
	    InvokeNetboxRequest -URI $uri
	}
	
	function VerifyIPAMChoices {
	<#
	    .SYNOPSIS
	        Internal function to verify provided values for static choices
	    
	    .DESCRIPTION
	        When users connect to the API, choices for each major object are cached to the config variable.
	        These values are then utilized to verify if the provided value from a user is valid.
	    
	    .PARAMETER ProvidedValue
	        The value to validate against static choices
	    
	    .PARAMETER AggregateFamily
	        Verify against aggregate family values
	    
	    .PARAMETER PrefixFamily
	        Verify against prefix family values
	    
	    .PARAMETER PrefixStatus
	        Verify against prefix status values
	    
	    .PARAMETER IPAddressFamily
	        Verify against ip-address family values
	    
	    .PARAMETER IPAddressStatus
	        Verify against ip-address status values
	    
	    .PARAMETER IPAddressRole
	        Verify against ip-address role values
	    
	    .PARAMETER VLANStatus
	        Verify against VLAN status values
	    
	    .PARAMETER ServiceProtocol
	        Verify against service protocol values
	    
	    .EXAMPLE
	        PS C:\> VerifyIPAMChoices -ProvidedValue 'loopback' -IPAddressRole
	    
	    .EXAMPLE
	        PS C:\> VerifyIPAMChoices -ProvidedValue 'Loopback' -IPAddressFamily
	        >> Invalid value Loopback for ip-address:family. Must be one of: 4, 6, IPv4, IPv6
	    
	    .OUTPUTS
	        This function returns the integer value if valid. Otherwise, it will throw an error.
	    
	    .NOTES
	        Additional information about the function.
	    
	    .FUNCTIONALITY
	        This cmdlet is intended to be used internally and not exposed to the user
	#>
	    
	    [CmdletBinding(DefaultParameterSetName = 'service:protocol')]
	    [OutputType([uint16])]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [object]$ProvidedValue,
	        
	        [Parameter(ParameterSetName = 'aggregate:family',
	                   Mandatory = $true)]
	        [switch]$AggregateFamily,
	        
	        [Parameter(ParameterSetName = 'prefix:family',
	                   Mandatory = $true)]
	        [switch]$PrefixFamily,
	        
	        [Parameter(ParameterSetName = 'prefix:status',
	                   Mandatory = $true)]
	        [switch]$PrefixStatus,
	        
	        [Parameter(ParameterSetName = 'ip-address:family',
	                   Mandatory = $true)]
	        [switch]$IPAddressFamily,
	        
	        [Parameter(ParameterSetName = 'ip-address:status',
	                   Mandatory = $true)]
	        [switch]$IPAddressStatus,
	        
	        [Parameter(ParameterSetName = 'ip-address:role',
	                   Mandatory = $true)]
	        [switch]$IPAddressRole,
	        
	        [Parameter(ParameterSetName = 'vlan:status',
	                   Mandatory = $true)]
	        [switch]$VLANStatus,
	        
	        [Parameter(ParameterSetName = 'service:protocol',
	                   Mandatory = $true)]
	        [switch]$ServiceProtocol
	    )
	    
	    ValidateChoice -MajorObject 'IPAM' -ChoiceName $PSCmdlet.ParameterSetName -ProvidedValue $ProvidedValue
	}
	
	
	function Get-NetboxIPAMAggregate {
	    [CmdletBinding()]
	    [Diagnostics.CodeAnalysis.SuppressMessageAttribute("PSUseSingularNouns", "", Justification = "These are literally 'choices' in Netbox")]
	    param
	    (
	        [uint16]$Limit,
	        
	        [uint16]$Offset,
	        
	        [object]$Family,
	        
	        [datetime]$Date_Added,
	        
	        [uint16[]]$Id,
	        
	        [string]$Query,
	        
	        [uint16]$RIR_Id,
	        
	        [string]$RIR,
	        
	        [switch]$Raw
	    )
	    
	    if ($null -ne $Family) {
	        $PSBoundParameters.Family = VerifyIPAMChoices -ProvidedValue $Family -AggregateFamily
	    }
	    
	    $Segments = [System.Collections.ArrayList]::new(@('ipam', 'aggregates'))
	    
	    $URIComponents = BuildURIComponents -URISegments $Segments.Clone() -ParametersDictionary $PSBoundParameters
	    
	    $uri = BuildNewURI -Segments $URIComponents.Segments -Parameters $URIComponents.Parameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	function Get-NetboxIPAMAddress {
	    [CmdletBinding()]
	    param
	    (
	        [uint16]$Limit,
	        
	        [uint16]$Offset,
	        
	        [object]$Family,
	        
	        [uint16[]]$Id,
	        
	        [string]$Query,
	        
	        [uint16]$Parent,
	        
	        [byte]$Mask_Length,
	        
	        [string]$VRF,
	        
	        [uint16]$VRF_Id,
	        
	        [string]$Tenant,
	        
	        [uint16]$Tenant_Id,
	        
	        [string]$Device,
	        
	        [uint16]$Device_ID,
	        
	        [string]$Virtual_Machine,
	        
	        [uint16]$Virtual_Machine_Id,
	        
	        [uint16]$Interface_Id,
	        
	        [object]$Status,
	        
	        [object]$Role,
	        
	        [switch]$Raw
	    )
	    
	    if ($null -ne $Family) {
	        $PSBoundParameters.Family = VerifyIPAMChoices -ProvidedValue $Family -IPAddressFamily
	    }
	    
	    if ($null -ne $Status) {
	        $PSBoundParameters.Status = VerifyIPAMChoices -ProvidedValue $Status -IPAddressStatus
	    }
	    
	    if ($null -ne $Role) {
	        $PSBoundParameters.Role = VerifyIPAMChoices -ProvidedValue $Role -IPAddressRole
	    }
	    
	    $Segments = [System.Collections.ArrayList]::new(@('ipam', 'ip-addresses'))
	    
	    $URIComponents = BuildURIComponents -URISegments $Segments -ParametersDictionary $PSBoundParameters
	    
	    $uri = BuildNewURI -Segments $URIComponents.Segments -Parameters $URIComponents.Parameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	function Get-NetboxIPAMAvailableIP {
	<#
	    .SYNOPSIS
	        A convenience method for returning available IP addresses within a prefix
	    
	    .DESCRIPTION
	        By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit
	        (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated
	    
	    .PARAMETER Prefix_ID
	        A description of the Prefix_ID parameter.
	    
	    .PARAMETER NumberOfIPs
	        A description of the NumberOfIPs parameter.
	    
	    .PARAMETER Raw
	        A description of the Raw parameter.
	    
	    .EXAMPLE
	        PS C:\> Get-NetboxIPAMAvaiableIP -Prefix_ID $value1
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [uint16]$Prefix_ID,
	        
	        [Alias('NumberOfIPs')]
	        [uint16]$Limit,
	        
	        [switch]$Raw
	    )
	    
	    $Segments = [System.Collections.ArrayList]::new(@('ipam', 'prefixes', $Prefix_ID, 'available-ips'))
	    
	    $URIComponents = BuildURIComponents -URISegments $Segments -ParametersDictionary $PSBoundParameters -SkipParameterByName 'prefix_id'
	    
	    $uri = BuildNewURI -Segments $URIComponents.Segments -Parameters $URIComponents.Parameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	function Get-NetboxIPAMPrefix {
	<#
	    .SYNOPSIS
	        A brief description of the Get-NetboxIPAMPrefix function.
	    
	    .DESCRIPTION
	        A detailed description of the Get-NetboxIPAMPrefix function.
	    
	    .PARAMETER Limit
	        A description of the Limit parameter.
	    
	    .PARAMETER Offset
	        A description of the Offset parameter.
	    
	    .PARAMETER Family
	        A description of the Family parameter.
	    
	    .PARAMETER Is_Pool
	        A description of the Is_Pool parameter.
	    
	    .PARAMETER Id
	        A description of the Id parameter.
	    
	    .PARAMETER Query
	        A description of the Query parameter.
	    
	    .PARAMETER Within
	        Should be a CIDR notation prefix such as '10.0.0.0/16'
	    
	    .PARAMETER Within_Include
	        Should be a CIDR notation prefix such as '10.0.0.0/16'
	    
	    .PARAMETER Contains
	        A description of the Contains parameter.
	    
	    .PARAMETER Mask_Length
	        CIDR mask length value
	    
	    .PARAMETER VRF
	        A description of the VRF parameter.
	    
	    .PARAMETER VRF_Id
	        A description of the VRF_Id parameter.
	    
	    .PARAMETER Tenant
	        A description of the Tenant parameter.
	    
	    .PARAMETER Tenant_Id
	        A description of the Tenant_Id parameter.
	    
	    .PARAMETER Site
	        A description of the Site parameter.
	    
	    .PARAMETER Site_Id
	        A description of the Site_Id parameter.
	    
	    .PARAMETER Vlan_VId
	        A description of the Vlan_VId parameter.
	    
	    .PARAMETER Vlan_Id
	        A description of the Vlan_Id parameter.
	    
	    .PARAMETER Status
	        A description of the Status parameter.
	    
	    .PARAMETER Role
	        A description of the Role parameter.
	    
	    .PARAMETER Role_Id
	        A description of the Role_Id parameter.
	    
	    .PARAMETER Raw
	        A description of the Raw parameter.
	    
	    .EXAMPLE
	        		PS C:\> Get-NetboxIPAMPrefix
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    param
	    (
	        [uint16]$Limit,
	        
	        [uint16]$Offset,
	        
	        [object]$Family,
	        
	        [boolean]$Is_Pool,
	        
	        [uint16[]]$Id,
	        
	        [string]$Query,
	        
	        [string]$Within,
	        
	        [string]$Within_Include,
	        
	        [string]$Contains,
	        
	        [ValidateRange(0, 127)]
	        [byte]$Mask_Length,
	        
	        [string]$VRF,
	        
	        [uint16]$VRF_Id,
	        
	        [string]$Tenant,
	        
	        [uint16]$Tenant_Id,
	        
	        [string]$Site,
	        
	        [uint16]$Site_Id,
	        
	        [string]$Vlan_VId,
	        
	        [uint16]$Vlan_Id,
	        
	        [object]$Status,
	        
	        [string]$Role,
	        
	        [uint16]$Role_Id,
	        
	        [switch]$Raw
	    )
	    
	    if ($null -ne $Family) {
	        $PSBoundParameters.Family = VerifyIPAMChoices -ProvidedValue $Family -PrefixFamily
	    }
	    
	    if ($null -ne $Status) {
	        $PSBoundParameters.Status = VerifyIPAMChoices -ProvidedValue $Status -PrefixStatus
	    }
	    
	    $Segments = [System.Collections.ArrayList]::new(@('ipam', 'prefixes'))
	    
	    $URIComponents = BuildURIComponents -URISegments $Segments -ParametersDictionary $PSBoundParameters
	    
	    $uri = BuildNewURI -Segments $URIComponents.Segments -Parameters $URIComponents.Parameters
	    
	    InvokeNetboxRequest -URI $uri -Raw:$Raw
	}
	
	function New-NetboxIPAMAddress {
	<#
	    .SYNOPSIS
	        Create a new IP address to Netbox
	    
	    .DESCRIPTION
	        Create a new IP address to Netbox with a status of Active by default.
	    
	    .PARAMETER Address
	        IP address in CIDR notation: 192.168.1.1/24
	    
	    .PARAMETER Status
	        Status of the IP. Defaults to Active
	    
	    .PARAMETER Tenant
	        Tenant ID
	    
	    .PARAMETER VRF
	        VRF ID
	    
	    .PARAMETER Role
	        Role such as anycast, loopback, etc... Defaults to nothing
	    
	    .PARAMETER NAT_Inside
	        ID of IP for NAT
	    
	    .PARAMETER Custom_Fields
	        Custom field hash table. Will be validated by the API service
	    
	    .PARAMETER Interface
	        ID of interface to apply IP
	    
	    .PARAMETER Description
	        Description of IP address
	    
	    .PARAMETER Raw
	        Return raw results from API service
	    
	    .EXAMPLE
	        PS C:\> Create-NetboxIPAMAddress
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding()]
	    [OutputType([pscustomobject])]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [string]$Address,
	        
	        [object]$Status = 'Active',
	        
	        [uint16]$Tenant,
	        
	        [uint16]$VRF,
	        
	        [object]$Role,
	        
	        [uint16]$NAT_Inside,
	        
	        [hashtable]$Custom_Fields,
	        
	        [uint16]$Interface,
	        
	        [string]$Description,
	        
	        [switch]$Raw
	    )
	    
	    $PSBoundParameters.Status = VerifyIPAMChoices -ProvidedValue $Status -IPAddressStatus
	    
	    if ($null -ne $Role) {
	        $PSBoundParameters.Role = VerifyIPAMChoices -ProvidedValue $Role -IPAddressRole
	    }
	    
	    $segments = [System.Collections.ArrayList]::new(@('ipam', 'ip-addresses'))
	    
	    $URIComponents = BuildURIComponents -URISegments $segments -ParametersDictionary $PSBoundParameters
	    
	    $URI = BuildNewURI -Segments $URIComponents.Segments
	    
	    InvokeNetboxRequest -URI $URI -Method POST -Body $URIComponents.Parameters -Raw:$Raw
	}
	
	function Remove-NetboxIPAMAddress {
	<#
	    .SYNOPSIS
	        Remove an IP address from Netbox
	    
	    .DESCRIPTION
	        Removes/deletes an IP address from Netbox by ID and optional other filters
	    
	    .PARAMETER Id
	        A description of the Id parameter.
	    
	    .PARAMETER Force
	        A description of the Force parameter.
	    
	    .PARAMETER Query
	        A description of the Query parameter.
	    
	    .EXAMPLE
	        PS C:\> Remove-NetboxIPAMAddress -Id $value1
	    
	    .NOTES
	        Additional information about the function.
	#>
	    
	    [CmdletBinding(ConfirmImpact = 'High',
	                   SupportsShouldProcess = $true)]
	    param
	    (
	        [Parameter(Mandatory = $true)]
	        [uint16[]]$Id,
	        
	        [switch]$Force
	    )
	    
	    $CurrentIPs = @(Get-NetboxIPAMAddress -Id $Id -ErrorAction Stop)
	    
	    $Segments = [System.Collections.ArrayList]::new(@('ipam', 'ip-addresses'))
	    
	    foreach ($IP in $CurrentIPs) {
	        if ($Force -or $pscmdlet.ShouldProcess($IP.Address, "Delete")) {
	            $URIComponents = BuildURIComponents -URISegments $Segments.Clone() -ParametersDictionary @{'id' = $IP.Id}
	            
	            $URI = BuildNewURI -Segments $URIComponents.Segments
	            
	            InvokeNetboxRequest -URI $URI -Method DELETE
	        }
	    }
	}
	
	function Set-NetboxIPAMAddress {
	    [CmdletBinding(ConfirmImpact = 'High',
	                   SupportsShouldProcess = $true)]
	    param
	    (
	        [Parameter(Mandatory = $true,
	                   ValueFromPipelineByPropertyName = $true)]
	        [uint16]$Id,
	        
	        [string]$Address,
	        
	        [object]$Status,
	        
	        [uint16]$Tenant,
	        
	        [uint16]$VRF,
	        
	        [object]$Role,
	        
	        [uint16]$NAT_Inside,
	        
	        [hashtable]$Custom_Fields,
	        
	        [uint16]$Interface,
	        
	        [string]$Description,
	        
	        [switch]$Force
	    )
	    
	    if ($Status) {
	        $PSBoundParameters.Status = VerifyIPAMChoices -ProvidedValue $Status -IPAddressStatus
	    }
	    
	    if ($Role) {
	        $PSBoundParameters.Role = VerifyIPAMChoices -ProvidedValue $Role -IPAddressRole
	    }
	    
	    $Segments = [System.Collections.ArrayList]::new(@('ipam', 'ip-addresses', $Id))
	    
	    Write-Verbose "Obtaining IPs from ID $Id"
	    $CurrentIP = Get-NetboxIPAMAddress -Id $Id -ErrorAction Stop
	    
	    if ($Force -or $PSCmdlet.ShouldProcess($($CurrentIP | Select-Object -ExpandProperty 'Address'), 'Set')) {
	        $URIComponents = BuildURIComponents -URISegments $Segments.Clone() -ParametersDictionary $PSBoundParameters -SkipParameterByName 'Id', 'Force'
	        
	        $URI = BuildNewURI -Segments $URIComponents.Segments
	        
	        InvokeNetboxRequest -URI $URI -Body $URIComponents.Parameters -Method PATCH
	    }
	}
	
	
	
	
	
	
	
	
	
	
	#endregion

# Build a list of common paramters so we can omit them to build URI parameters
$script:CommonParameterNames = New-Object System.Collections.ArrayList
[void]$script:CommonParameterNames.AddRange(@([System.Management.Automation.PSCmdlet]::CommonParameters))
[void]$script:CommonParameterNames.AddRange(@([System.Management.Automation.PSCmdlet]::OptionalCommonParameters))
[void]$script:CommonParameterNames.Add('Raw')

SetupNetboxConfigVariable

#Export-ModuleMember -Function *
Export-ModuleMember -Function *-*